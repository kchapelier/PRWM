(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.threeBuffergeometryToPrwm=f()}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){"use strict";var prwm=require("prwm");var bufferGeometryToPrwm=function bufferGeometryToPrwm(bufferGeometry,bigEndian){if(bufferGeometry.type!=="BufferGeometry"){throw new Error("three-buffergeometry-to-prwm can only be used with an instance of THREE.BufferGeometry")}var attributes={},indices=null,attributeKeys=Object.keys(bufferGeometry.attributes),i=0,attribute;for(;i<attributeKeys.length;i++){attribute=bufferGeometry.attributes[attributeKeys[i]];attributes[attributeKeys[i]]={cardinality:attribute.itemSize,normalized:attribute.normalized,type:attribute.array instanceof Float32Array||attribute.array instanceof Float64Array?prwm.Float:prwm.Int,values:attribute.array}}if(bufferGeometry.index){indices=bufferGeometry.index.array}return prwm.encode(attributes,indices,!!bigEndian)};module.exports=bufferGeometryToPrwm},{prwm:2}],2:[function(require,module,exports){"use strict";var attributeTypes=require("./prwm/attribute-types");module.exports={version:1,Int:attributeTypes.Int,Float:attributeTypes.Float,isBigEndianPlatform:require("./utils/is-big-endian-platform"),encode:require("./prwm/encode"),decode:require("./prwm/decode")}},{"./prwm/attribute-types":3,"./prwm/decode":4,"./prwm/encode":5,"./utils/is-big-endian-platform":6}],3:[function(require,module,exports){"use strict";module.exports={Float:0,Int:1}},{}],4:[function(require,module,exports){"use strict";var isBigEndianPlatform=require("../utils/is-big-endian-platform");var InvertedEncodingTypes=[null,Float32Array,null,Int8Array,Int16Array,null,Int32Array,Uint8Array,Uint16Array,null,Uint32Array];var getMethods={Uint16Array:"getUint16",Uint32Array:"getUint32",Int16Array:"getInt16",Int32Array:"getInt32",Float32Array:"getFloat32"};function copyFromBuffer(sourceArrayBuffer,viewType,position,length,fromBigEndian){var bytesPerElement=viewType.BYTES_PER_ELEMENT,result;if(fromBigEndian===isBigEndianPlatform()||bytesPerElement===1){result=new viewType(sourceArrayBuffer,position,length)}else{var readView=new DataView(sourceArrayBuffer,position,length*bytesPerElement),getMethod=getMethods[viewType.name],littleEndian=!fromBigEndian;result=new viewType(length);for(var i=0;i<length;i++){result[i]=readView[getMethod](i*bytesPerElement,littleEndian)}}return result}function decode(buffer,offset){offset=offset||0;var array=new Uint8Array(buffer,offset),version=array[0],flags=array[1],indexedGeometry=!!(flags>>7),indicesType=flags>>6&1,bigEndian=(flags>>5&1)===1,attributesNumber=flags&31,valuesNumber=0,indicesNumber=0;if(bigEndian){valuesNumber=(array[2]<<16)+(array[3]<<8)+array[4];indicesNumber=(array[5]<<16)+(array[6]<<8)+array[7]}else{valuesNumber=array[2]+(array[3]<<8)+(array[4]<<16);indicesNumber=array[5]+(array[6]<<8)+(array[7]<<16)}if(offset/4%1!==0){throw new Error("PRWM decoder: Offset should be a multiple of 4, received "+offset)}if(version===0){throw new Error("PRWM decoder: Invalid format version: 0")}else if(version!==1){throw new Error("PRWM decoder: Unsupported format version: "+version)}if(!indexedGeometry){if(indicesType!==0){throw new Error("PRWM decoder: Indices type must be set to 0 for non-indexed geometries")}else if(indicesNumber!==0){throw new Error("PRWM decoder: Number of indices must be set to 0 for non-indexed geometries")}}var pos=8;var attributes={},attributeName,char,attributeNormalized,attributeType,cardinality,encodingType,arrayType,values,i;for(i=0;i<attributesNumber;i++){attributeName="";while(pos<array.length){char=array[pos];pos++;if(char===0){break}else{attributeName+=String.fromCharCode(char)}}flags=array[pos];attributeType=flags>>7&1;attributeNormalized=!!(flags>>6&1);cardinality=(flags>>4&3)+1;encodingType=flags&15;arrayType=InvertedEncodingTypes[encodingType];pos++;pos=Math.ceil(pos/4)*4;values=copyFromBuffer(buffer,arrayType,pos+offset,cardinality*valuesNumber,bigEndian);pos+=arrayType.BYTES_PER_ELEMENT*cardinality*valuesNumber;attributes[attributeName]={type:attributeType,normalized:attributeNormalized,cardinality:cardinality,values:values}}pos=Math.ceil(pos/4)*4;var indices=null;if(indexedGeometry){indices=copyFromBuffer(buffer,indicesType===1?Uint32Array:Uint16Array,pos+offset,indicesNumber,bigEndian)}return{version:version,bigEndian:bigEndian,attributes:attributes,indices:indices}}module.exports=decode},{"../utils/is-big-endian-platform":6}],5:[function(require,module,exports){"use strict";var isBigEndianPlatform=require("../utils/is-big-endian-platform"),attributeTypes=require("./attribute-types");var EncodingTypes={Float32Array:1,Int8Array:3,Int16Array:4,Int32Array:6,Uint8Array:7,Uint16Array:8,Uint32Array:10};var setMethods={Uint16Array:"setUint16",Uint32Array:"setUint32",Int16Array:"setInt16",Int32Array:"setInt32",Float32Array:"setFloat32"};function copyToBuffer(sourceTypedArray,destinationArrayBuffer,position,bigEndian){var length=sourceTypedArray.length,bytesPerElement=sourceTypedArray.BYTES_PER_ELEMENT;var writeArray=new sourceTypedArray.constructor(destinationArrayBuffer,position,length);if(bigEndian===isBigEndianPlatform()||bytesPerElement===1){writeArray.set(sourceTypedArray.subarray(0,length))}else{var writeView=new DataView(destinationArrayBuffer,position,length*bytesPerElement),setMethod=setMethods[sourceTypedArray.constructor.name],littleEndian=!bigEndian,i=0;for(i=0;i<length;i++){writeView[setMethod](i*bytesPerElement,sourceTypedArray[i],littleEndian)}}return writeArray}function encode(attributes,indices,bigEndian){var attributeKeys=attributes?Object.keys(attributes):[],indexedGeometry=!!indices,i,j;if(attributeKeys.length===0){throw new Error("PRWM encoder: The model must have at least one attribute")}if(attributeKeys.length>31){throw new Error("PRWM encoder: The model can have at most 31 attributes")}for(i=0;i<attributeKeys.length;i++){if(!EncodingTypes.hasOwnProperty(attributes[attributeKeys[i]].values.constructor.name)){throw new Error("PRWM encoder: Unsupported attribute values type: "+attributes[attributeKeys[i]].values.constructor.name)}}if(indexedGeometry&&indices.constructor.name!=="Uint16Array"&&indices.constructor.name!=="Uint32Array"){throw new Error("PRWM encoder: The indices must be represented as an Uint16Array or an Uint32Array")}var valuesNumber=attributes[attributeKeys[0]].values.length/attributes[attributeKeys[0]].cardinality|0,indicesNumber=indexedGeometry?indices.length:0,indicesType=indexedGeometry&&indices.constructor.name==="Uint32Array"?1:0;var totalLength=8,attributeKey,attribute,attributeType,attributeNormalized;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];totalLength+=attributeKey.length+2;totalLength=Math.ceil(totalLength/4)*4;totalLength+=attribute.values.byteLength}if(indexedGeometry){totalLength=Math.ceil(totalLength/4)*4;totalLength+=indices.byteLength}var buffer=new ArrayBuffer(totalLength),array=new Uint8Array(buffer);array[0]=1;array[1]=indexedGeometry<<7|indicesType<<6|(bigEndian?1:0)<<5|attributeKeys.length&31;if(bigEndian){array[2]=valuesNumber>>16&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber&255;array[5]=indicesNumber>>16&255;array[6]=indicesNumber>>8&255;array[7]=indicesNumber&255}else{array[2]=valuesNumber&255;array[3]=valuesNumber>>8&255;array[4]=valuesNumber>>16&255;array[5]=indicesNumber&255;array[6]=indicesNumber>>8&255;array[7]=indicesNumber>>16&255}var pos=8;for(i=0;i<attributeKeys.length;i++){attributeKey=attributeKeys[i];attribute=attributes[attributeKey];attributeType=typeof attribute.type==="undefined"?attributeTypes.Float:attribute.type;attributeNormalized=!!attribute.normalized?1:0;for(j=0;j<attributeKey.length;j++,pos++){array[pos]=attributeKey.charCodeAt(j)&127||95}pos++;array[pos]=attributeType<<7|attributeNormalized<<6|(attribute.cardinality-1&3)<<4|EncodingTypes[attribute.values.constructor.name]&15;pos++;pos=Math.ceil(pos/4)*4;var attributesWriteArray=copyToBuffer(attribute.values,buffer,pos,bigEndian);pos+=attributesWriteArray.byteLength}if(indexedGeometry){pos=Math.ceil(pos/4)*4;copyToBuffer(indices,buffer,pos,bigEndian)}return buffer}module.exports=encode},{"../utils/is-big-endian-platform":6,"./attribute-types":3}],6:[function(require,module,exports){"use strict";var bigEndianPlatform=null;function isBigEndianPlatform(){if(bigEndianPlatform===null){var buffer=new ArrayBuffer(2),uint8Array=new Uint8Array(buffer),uint16Array=new Uint16Array(buffer);uint8Array[0]=170;uint8Array[1]=187;bigEndianPlatform=uint16Array[0]===43707}return bigEndianPlatform}module.exports=isBigEndianPlatform},{}]},{},[1])(1)});
